#include "i2c.h"

// Constructors ////////////////////////////////////////////////////////////////

Wire::Wire() {
}

// Public Methods //////////////////////////////////////////////////////////////

void Wire::init(I2C_XFER_T *xfer1, I2C_XFER_T *xfer2, uint8_t *data1, uint8_t *data2) {
	/* Initialize the I2C bus (i2c_app_init) */
	I2C_ID_T id = I2C0; // Select I2C peripheral
	static I2C_ID_T i2cDev = I2C0; // Active I2C
	int speed = SPEED_400KHZ; // I2C clock rate

	// Init I2C Pin Mux (Init_I2C_PinMux)
#if (defined(BOARD_NXP_XPRESSO_11U14) || defined(BOARD_NGX_BLUEBOARD_11U24))
	Chip_SYSCTL_PeriphReset(RESET_I2C0);
	Chip_IOCON_PinMuxSet(LPC_IOCON, 0, 4, IOCON_FUNC1 | I2C_FASTPLUS_BIT);
	Chip_IOCON_PinMuxSet(LPC_IOCON, 0, 5, IOCON_FUNC1 | I2C_FASTPLUS_BIT);
#elif (defined(BOARD_NXP_XPRESSO_11C24) || defined(BOARD_MCORE48_1125))
	Chip_SYSCTL_PeriphReset(RESET_I2C0);
	Chip_IOCON_PinMuxSet(LPC_IOCON, IOCON_PIO0_4, IOCON_FUNC1 | I2C_FASTPLUS_BIT);
	Chip_IOCON_PinMuxSet(LPC_IOCON, IOCON_PIO0_5, IOCON_FUNC1 | I2C_FASTPLUS_BIT);
#else
#error "No Pin Muxing defined for I2C operation"
#endif

	// Initialize I2C
	Chip_I2C_Init(id);
	Chip_I2C_SetClockRate(id, speed);

	// Set I2C mode to polling/interrupt (i2c_set_mode)
	i2cSetMode(id, 0); // Set default mode to interrupt

	/* Simulate IO Expansion slave (i2c_iox_init) */
	i2c_dev_init(i2cDev, &agXfer, I2C_SLAVE_0, I2C_SLAVE_AG_ADDR, &ag_data, &i2c_dev_event);

	mXfer.slaveAddr = (addr2 << 1);
	mXfer.rxBuff = &m_data[1];
	mXfer.rxSz = sizeof(m_data);
	mXfer.txBuff = (const uint8_t *) m_data;
	mXfer.txSz = sizeof(m_data) + 1;
	Chip_I2C_SlaveSetup(id, I2C_SLAVE_1, &m_xfer, i2c_m_events, 0);
	// Update out port
	Board_LED_Set(0, m_data[1] & 1);
	Board_LED_Set(1, m_data[1] & 2);
	Board_LED_Set(2, m_data[1] & 4);
	Board_LED_Set(3, m_data[1] & 8);
#ifndef CHIP_LPC11CXX
	// update in port
	m_data[0] = (uint8_t) Buttons_GetStatus();
#endif
	// Setup SysTick timer to get the button status updated at regular intervals
	SysTick_Config(Chip_Clock_GetSystemClockRate() / 50);

	/* Select I2C peripheral */
	i2cDev = I2C0;

}

// must be called in:
// slave tx event callback
// or after beginTransmission(address)
size_t Wire::write(I2C_XFER_T *xfer, uint8_t slaveAddr, uint8_t data) {
	int length;

	xfer->slaveAddr = (slaveAddr << 1);
	xfer->rxBuff = 0;
	xfer->txBuff = 0;
	xfer->txSz = 0;
	xfer->rxSz = 0;

	buffer[0][1] = data;
	xfer->txSz = length;
	xfer->txBuff = buffer[0];

	if (xfer->txSz == 0) {
		return 0;
	}

	return Chip_I2C_MasterSend(i2cDev, xfer->slaveAddr, xfer->txBuff, xfer->txSz);
}

// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int Wire::read(I2C_XFER_T *xfer, uint8_t slaveAddr, int length) {
	xfer->slaveAddr = slaveAddr;
	xfer->rxBuff = 0;
	xfer->txBuff = 0;
	xfer->txSz = 0;
	xfer->rxSz = 0;

	xfer->rxSz = length;
	xfer->rxBuff = buffer[1];

	length = Chip_I2C_MasterRead(i2cDev, xfer->slaveAddr, xfer->rxBuff, xfer->rxSz);
	return length;
}

// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
I2C_STATUS_T Wire::status(I2C_XFER_T *xfer) {
	return xfer->status;
}

void Wire::setMode(I2C_ID_T id, bool polling) {
	if (!polling) { // Set mode to interrupt
		mode_poll &= ~(1 << id);
		Chip_I2C_SetMasterEventHandler(id, Chip_I2C_EventHandler);
		NVIC_EnableIRQ(I2C0_IRQn);
	} else { // Set mode to polling
		mode_poll |= 1 << id;
		NVIC_DisableIRQ(I2C0_IRQn);
		Chip_I2C_SetMasterEventHandler(id, Chip_I2C_EventHandlerPolling);
	}
}

// Simulate an IO Expansion slave device
static void i2c_dev_init(I2C_ID_T id, I2C_XFER_T *xfer, I2C_SLAVE_ID sid, uint8_t addr, uint8_t *data, I2C_EVENTHANDLER_T event) {
#ifndef CHIP_LPC11CXX
	Board_Buttons_Init();
#endif
	xfer.slaveAddr = (addr << 1);
	event(id, &agXfer, &data, &I2C_EVENT_DONE);
	Chip_I2C_SlaveSetup(id, sid, &xfer, event, 0);
	i2c_dev_update_regs(3);
	// Setup SysTick timer to get the button status updated at regular intervals
	SysTick_Config(Chip_Clock_GetSystemClockRate() / 50);
}

// Slave event handler for simulated EEPROM
static void Wire::i2c_dev_event(I2C_ID_T id, I2C_XFER_T *xfer, uint8_t *data, I2C_EVENT_T event) {
	switch (event) {
	case I2C_EVENT_DONE:
		xfer.rxBuff = &iox_data[1];
		xfer.rxSz = sizeof(iox_data);
		xfer.txBuff = (const uint8_t *) iox_data;
		xfer.txSz = sizeof(iox_data) + 1;
		break;

	case I2C_EVENT_SLAVE_RX:
		xfer.rxBuff = &iox_data[1];
		xfer.rxSz = sizeof(iox_data);
		i2c_dev_update_regs(1);
		break;

	case I2C_EVENT_SLAVE_TX:
		if (xfer.txSz == 1) {
			xfer.txBuff = (const uint8_t *) iox_data[0];
			xfer.txSz = sizeof(iox_data) + 1;
		}
		break;
	}
}

// Update IN/OUT port states to real devices
void Wire::i2c_dev_update_regs(int ops) {
	if (ops & 1) {	// update out port
		Board_LED_Set(0, iox_data[1] & 1);
		Board_LED_Set(1, iox_data[1] & 2);
		Board_LED_Set(2, iox_data[1] & 4);
		Board_LED_Set(3, iox_data[1] & 8);
	}
#ifndef CHIP_LPC11CXX
	if (ops & 2) {	// update in port
		iox_data[0] = (uint8_t) Buttons_GetStatus();
	}
#endif
}

// Preinstantiate Objects //////////////////////////////////////////////////////
Wire i2c = Wire();

