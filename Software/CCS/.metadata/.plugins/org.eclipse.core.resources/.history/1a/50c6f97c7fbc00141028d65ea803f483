// roveTcpHandler.c
//
// first created:
//
// 01_22_2015_Owen_Chiaventone
//
// last edited:
//
//02_24_2015_Judah Schad_jrs6w7@mst.edu

//this implements a single function BIOS thread that acts as the RoverMotherboard.cfg roveTcpHandlerTask handle
//
//recieves base station commands and send device telemetry using tcp ip bsd sockets

#include "roveTcpHandler.h"



//BIOS_start inits the roveTcpHandlerTask ::	priority 1, vital_flag = t, 2048 persistent private stack

Void roveTcpHandler(UArg arg0, UArg arg1){

	//init socket file env, json parser, msg structs

	fdOpenSession(TaskSelf());

	//init tcp socket handle

    int              clientfd = 0;
    struct 			 sockaddr_in localAddr;
	int              connect_success = 0;
    int              connectedFlag = NOT_CONNECTED;

    //init RoveNet Recieve struct

    base_station_msg_struct fromBaseCmd;

    //init RoveNet Recieve struct

    base_station_msg_struct toBaseTelem;

    //init keep alive handles

    int             bytesSent = 0;
    int    			KEEPALIVE_SIZE = 9;
    struct 			timeval  timeout;


	//the task loops for ever

	//it sleeps on the Mailbox_post to roveCommandController Task

	//it awakes on full Mailbox_pend from roveTelemController Task

	//it only exits from BIOS_start, on error state

    while(1){

    	//init socket

       	clientfd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);

       	//flag for bad socket

		if(clientfd == INVALID_SOCKET){

			System_printf("Failed Socket() create (src = socket()) (%d)\n",fdError());
			System_flush();

    	}//endif:	(clientfd == INVALID_SOCKET)

		//init bsd socket config struct

		memset(&localAddr, 0, sizeof(localAddr) );

		//config the socket

		localAddr.sin_family = AF_INET;
		localAddr.sin_port = htons(TCPPORT);

		inet_pton(AF_INET, RED_IP, &localAddr.sin_addr);

		timeout.tv_sec = 3600;
		timeout.tv_usec = 0;

		setsockopt(clientfd, SOL_SOCKET, SO_SNDTIMEO, &timeout, sizeof(timeout) );
		setsockopt(clientfd, SOL_SOCKET, SO_RCVTIMEO, &timeout, sizeof(timeout) );

		//connect the socket

		connect_success = connect(clientfd, (PSA)&localAddr, sizeof(localAddr) );

		//flag for failed connection

    	if(connect_success < 0){

    		connectedFlag = NOT_CONNECTED;

    		System_printf("Error: socket Accept() failed (src = connect())\n");
    		System_flush();

    	}else{

    		//we are now connected

    		connectedFlag = CONNECTED;

    	}//endifelse:	(connect_success < 0)

    	//loop to recieve from the base station, on socket breaking, attempt to reconnect

    	while(connectedFlag == CONNECTED){

    		//clean the structs for Mailbox_post:		.id is enum 	.value is char[MAX_COMMAND_SIZE]

    		fromBaseCmd.id = null_device;

    		fromBaseCm.value[0] = "00000";

    		//clean the structs for Mailbox_pend:		.id is enum 	.value is char[MAX_TELEM_SIZE]

    		toBaseTelem.id = null_device;

    		toBaseCm.value[0] = "00000";

    		bytesReceived = recv(clientfd, &fromBaseCmd, sizeof(struct base_station_msg_struct), 0);

    		//flag for lost connection

    		if(bytesReceived < 0){

    			connectedFlag = NOT_CONNECTED;

    			System_printf("Connection lost. (src = recv)\n");
    			System_flush();

    		}else{

    			//we have recieved

				//copies the packet buffer to the roveCmdCntrl Thread with SemaphorePost

				//implicitly task_sleep until till reawoken by roveTelemCntrl Thread with SemaphorePend

				//device dependent: Tiva C is little-endian, so this reads to the lsb of fromBaseCmd.id field

				 Mailbox_post(fromBaseStationMailbox, &fromBaseCmd, BIOS_WAIT_FOREVER);

    		}//endifelse:		(bytesReceived < 0)

    		//implicitly sleeps to allow the next Task to awake while Mailbox is full

			Mailbox_pend(fromDevicesnMailbox, &toBaseTelem, BIOS_WAIT_FOREVER);

			switch(toBaseTelem.id){

		    	//the robot arm is sending telemetry

		    	case robot_arm:

		    		bytesSent = send(clientfd,  &toBaseTele,  sizeof(struct test_device_data_struct), 0)

		    			 //copies the packet buffer to the roveCmdCntrl Thread with SemaphorePost

		    			 //implicitly task_sleep until till reawoken by roveTelemCntrl Thread with SemaphorePend

		    			 //device dependent: Tiva C is little-endian, so this reads to the lsb of fromBaseCmd.id field


		    			 break;

		    			 }//endswitch:	(fromBaseCmd.id)

		    		}//endif:		(bytesReceived < 0)

    		connectedFlag = NOT_CONNECTED;

    	    System_printf("Connection lost. (src = recv)\n");
    	    System_flush();

    } //endwhile(connectedFlag == CONNECTED)

    //If execution reaches this point, then the connection has broken

    close(clientfd);

} //end while(1)


//---- postcondition: Execution will not reach this state unless a serious error occurs

// Close the socket file env

fdCloseSession(TaskSelf());

System_printf("Tcp Handler Task Exit\n");
System_flush();

//exit Task

return;

}//end Function roveTcpHandler() Task
