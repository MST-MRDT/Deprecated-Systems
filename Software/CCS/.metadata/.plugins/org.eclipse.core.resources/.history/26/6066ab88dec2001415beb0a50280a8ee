/*
 * roveHardwareAbstraction.c
 *
 *  Created on: Mar 3, 2015
 *      Author: Owen
 */


#include "../roveWareHeaders/roveHardwareAbstraction.h"

void pinMode(int pin, int mode)
{
	//No idea how to start this one
}

void digitalWrite(int pin, int val)
{
	//Alarmingly enough, a switch case is really the only way to deal with this
	//Everything is base on a bunch of TI defined constants that can't be indexed into
	//Or iterated through

	if(val == LOW)
	{
		switch(pin)
		{
		case U3_MUX_S0 :
			GPIOPinWrite(GPIO_PORTH_BASE, GPIO_PIN_0, (0));
			break;
		case U3_MUX_S1 :
			GPIOPinWrite(GPIO_PORTH_BASE, GPIO_PIN_1, (0));
			break;
		case U4_MUX_S0 :
			GPIOPinWrite(GPIO_PORTM_BASE, GPIO_PIN_6, (0));
			break;
		case U4_MUX_S1 :
			GPIOPinWrite(GPIO_PORTM_BASE, GPIO_PIN_7, (0));
			break;
		case U5_MUX_S0 :
			GPIOPinWrite(GPIO_PORTL_BASE, GPIO_PIN_0, (0));
			break;
		case U5_MUX_S1 :
			GPIOPinWrite(GPIO_PORTL_BASE, GPIO_PIN_1, (0));
			break;
		case U6_MUX_S0 :
			GPIOPinWrite(GPIO_PORTK_BASE, GPIO_PIN_2, (0));
			break;
		case U6_MUX_S1 :
			GPIOPinWrite(GPIO_PORTK_BASE, GPIO_PIN_3, (0));
			break;
		case U7_MUX_S0 :
			GPIOPinWrite(GPIO_PORTE_BASE, GPIO_PIN_0, (0));
			break;
		case U7_MUX_S1 :
			GPIOPinWrite(GPIO_PORTE_BASE, GPIO_PIN_1, (0));
			break;
		}//endswitch
	} else if (val == HIGH)
	{
		switch(pin)
		{
		case U3_MUX_S0 :
			GPIOPinWrite(GPIO_PORTH_BASE, GPIO_PIN_0, (~0));
			break;
		case U3_MUX_S1 :
			GPIOPinWrite(GPIO_PORTH_BASE, GPIO_PIN_1, (~0));
			break;
		case U4_MUX_S0 :
			GPIOPinWrite(GPIO_PORTM_BASE, GPIO_PIN_6, (~0));
			break;
		case U4_MUX_S1 :
			GPIOPinWrite(GPIO_PORTM_BASE, GPIO_PIN_7, (~0));
			break;
		case U5_MUX_S0 :
			GPIOPinWrite(GPIO_PORTL_BASE, GPIO_PIN_0, (~0));
			break;
		case U5_MUX_S1 :
			GPIOPinWrite(GPIO_PORTL_BASE, GPIO_PIN_1, (~0));
			break;
		case U6_MUX_S0 :
			GPIOPinWrite(GPIO_PORTK_BASE, GPIO_PIN_2, (~0));
			break;
		case U6_MUX_S1 :
			GPIOPinWrite(GPIO_PORTK_BASE, GPIO_PIN_3, (~0));
			break;
		case U7_MUX_S0 :
			GPIOPinWrite(GPIO_PORTE_BASE, GPIO_PIN_0, (~0));
			break;
		case U7_MUX_S1 :
			GPIOPinWrite(GPIO_PORTE_BASE, GPIO_PIN_1, (~0));
			break;
		}//endswitch
	}
	return;

}

int deviceWrite(int rs485jack, char* buffer, int bytes_to_write)
{
	extern uart0;
	extern uart1;
	extern uart2;
	extern uart3;
	extern uart4;
	extern uart5;
	extern uart6;
	extern uart7;

	//Debug
	System_printf("deviceWrite called\n");
	System_flush();
	switch(rs485jack)
	{
	//We have to include case 0 to get TI's compiler to build a jump table
	//If we leave this out, mux performance goes from O(1) to O(n) (That's bad)
	case 0:
	case 1:
		//Configure the mux pins
		//See the mux datasheet for more info
		digitalWrite(U3_MUX_S0, LOW);
		digitalWrite(U3_MUX_S1, LOW);

		//Write the buffer to the device
		UART_write(uart3, buffer, bytes_to_write);
		break;
	case 2:
		digitalWrite(U3_MUX_S0, HIGH);
		digitalWrite(U3_MUX_S1, LOW);
		UART_write(uart3, buffer, bytes_to_write);
		break;
	case 3:
		digitalWrite(U4_MUX_S0, LOW);
		digitalWrite(U4_MUX_S1, LOW);
		UART_write(uart4, buffer, bytes_to_write);
		break;
	case 4:
		digitalWrite(U4_MUX_S0, HIGH);
		digitalWrite(U4_MUX_S1, LOW);
		UART_write(uart4, buffer, bytes_to_write);
		break;
	case 4:
		digitalWrite(U4_MUX_S0, LOW);
		digitalWrite(U4_MUX_S1, HIGH);
		UART_write(uart4, buffer, bytes_to_write);
		break;
	//etc.
	}

}

int deviceRead(int rs485jack, char* buffer, int buf_len, int timeout)
{
	/*
	switch(rs485jack)
	{
	case 1:
		digitalWrite(U1_MUX_S1, LOW)
		digitalWrite(U1_MUX_S0, LOW)
		//Read UART into buffer
		break;
	//etc.
	}
	*/
}

void initUarts()
{

}

void initMuxGPIO()
{
	//Probably just a bunch of pinModes.
}
