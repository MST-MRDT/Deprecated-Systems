// roveTcpHandler.c
// created on: Jan 22, 2015
// author: Owen Chiaventone, Judah Schad, Connor Walsh

#include "roveTcpHandler.h"

Void roveTcpHandler(UArg arg0, UArg arg1){

	//init socket file env, json parser, msg structs

	fdOpenSession(TaskSelf());

	//init tcp socket handle

    int              clientfd = 0;
    struct 			 sockaddr_in localAddr;
	int              connect_success = 0;
    int              connectedFlag = NOT_CONNECTED;

    //init RoveCom Struct

    base_station_msg_struct  fromBaseCmd;

    //init Keep Alive handle

    int             bytesSent = 0;
    int    			KEEPALIVE_SIZE = 9;
    struct 			timeval  timeout;


    //Task loops for ever

    //It sleeps on the Mailbox_post to roveCommandController Task

    //Unitl it awakes on full Mailbox_pend from roveTelemController Task

    //It only exits on error

    while(1){

    	//init socket

       	clientfd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);

    	//flag bad socket

		if(clientfd == INVALID_SOCKET){

			System_printf("Failed Socket() create (src = socket()) (%d)\n",fdError());
			System_flush();

    	}//endif(clientfd == INVALID_SOCKET)

		//init socket config struct

		memset(&localAddr, 0, sizeof(localAddr) );

		//config socket

		localAddr.sin_family = AF_INET;
		localAddr.sin_port = htons(TCPPORT);

		inet_pton(AF_INET, RED_IP, &localAddr.sin_addr);

		timeout.tv_sec = 3600;
		timeout.tv_usec = 0;

		setsockopt(clientfd, SOL_SOCKET, SO_SNDTIMEO, &timeout, sizeof(timeout) );
		setsockopt(clientfd, SOL_SOCKET, SO_RCVTIMEO, &timeout, sizeof(timeout) );

		//connect socket

		connect_success = connect(clientfd, (PSA)&localAddr, sizeof(localAddr) );

		//flag failed connection

    	if(connect_success < 0){

    		connectedFlag = NOT_CONNECTED;

    		System_printf("Error: socket Accept() failed (src = connect())\n");
    		System_flush();

    	}else{

    		connectedFlag = CONNECTED;

    	}//endif(connect_success < 0)

    	//loop to recieve, break to attempt reconnect

    	while(connectedFlag == CONNECTED){

    		bytesReceived = recv(clientfd, incomingBuffer, TCPPACKETSIZE, 0);

			//flag lost connection

    		if(bytesReceived < 0){

    			connectedFlag = NOT_CONNECTED;

    			System_printf("Connection lost. (src = recv)\n");
    			System_flush();

    		}else{

    			//connected

    			fromBaseCmd.id = (DeviceID)incomingBuffer[0];

    			switch(fromBaseCmd.id){

    			Mailbox_post(fromBaseStationMailbox, &fromBaseCmd, BIOS_WAIT_FOREVER);

			System_printf("Received data: %c\n", incomingBuffer[sizeOfMsg]);
			System_flush();

			//pass struct through to commandThread

			//implicitly sleeps to allow the next Task to awake while Mailbox is full

			Mailbox_post(fromBaseStationMailbox, &fromBaseCmd, BIOS_WAIT_FOREVER);

			//TODO Event handler for Telem Send
/*
			bytesSent = send(clientfd, "keepalive", KEEPALIVE_SIZE, 0);

			if (bytesSent < 0 || bytesSent != KEEPALIVE_SIZE) {

				System_printf("Error: send failed.\n");

				connectedFlag = NOT_CONNECTED;

				//Task_sleep(2000);	-> i++

				bytesSent = send(clientfd, "keepalive", KEEPALIVE_SIZE, 0);

				if (bytesSent < 0 || bytesSent != KEEPALIVE_SIZE) {

					System_printf("Error: send failed.\n");

					connectedFlag = NOT_CONNECTED;

				Mailbox_pend(toBaseStationMailbox, &toBaseTelem, BIOS_WAIT_FOREVER);

				}//endif (bytesSent < 0 || bytesSent != KEEPALIVE_SIZE)

			}//endif (bytesSent < 0 || bytesSent != KEEPALIVE_SIZE)
*/
    	}//endif(bytesReceived < 0)

    } //endwhile(connectedFlag == CONNECTED)

    //If execution reaches this point, then the connection has broken

    close(clientfd);

} //end while(1)


//---- postcondition: Execution will not reach this state unless a serious error occurs

// Close the socket file env

fdCloseSession(TaskSelf());

System_printf("Tcp Handler Task Exit\n");
System_flush();

//exit Task

return;

}//end Function roveTcpHandler() Task
