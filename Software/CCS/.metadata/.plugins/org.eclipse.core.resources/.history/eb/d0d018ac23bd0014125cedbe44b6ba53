//	TODO: Port To Fresh Build (using TI example:			This version educational practice not for distro)
//
// roveCmdCtrl.c
//
// first created:
//
// 01_22_2015_Owen_Chiaventone
//
// last edited:
//
//02_24_2015_Judah Schad_jrs6w7@mst.edu
//
// 	this implements a single function BIOS thread that acts as the RoverMotherboard.cfg roveCmdCtrlTask handle
//
//	recieves commands from roveTCPHandler in roveCom protocol using TI.Mailbox.from object and
//
//	sends requests to roveTelemCntrl for device telemetry in roveCom protocol using using TI.Mailbox.to object

#include "roveIncludes/roveCmdCntrl.h"

Void roveCmdCntrl(UArg arg0, UArg arg1){

	//external ref the scope for global uart handles

	extern UART_Handle uart0;
	extern UART_Handle uart1;
	extern UART_Handle uart2;
	extern UART_Handle uart3;
	extern UART_Handle uart4;
	extern UART_Handle uart5;
	extern UART_Handle uart6;
	extern UART_Handle uart7;

	//init and clean RoveCom msg recieve struct

	base_station_msg_struct fromBaseMsg;

	fromBaseMsg.id = null_device;

	memset(&fromBaseMsg.value, 0, sizeof(MAX_COMMAND_SIZE) );

	//init and clean RoveCom signal send struct

	signal_telem_control_struct signal_telem_struct;

	signal_telem_struct.id = null_device;

	signal_telem_struct.sig = null_signal;

	//init and clea RoveCom uart send struct

	struct motor_control_struct motor_control_struct;

	motor_control_struct.value = 0;

    //Task loops for ever

    //It sleeps on full Mailbox_post to roveTelemController Task

    //It awakes on full Mailbox_pend frome roveTelem Task

    //It only exits on error

	while(1){

				//read cmd from roveTCPHandler

				Mailbox_pend(fromBaseStationMailbox, &fromBaseMsg, BIOS_WAIT_FOREVER);

				switch(fromBaseMsg.id){

					//*************
					// Drive Left
					//*************

					//roveCom::	enum motor_left::	id = 100

					case motor_left:

						motor_control_struct.value = fromBaseMsg.value;

						mux_1( 8 );
						mux_2( 7 );
						mux_3( 6 );

						send_struct(uart1, &motor_control_struct, motor_controller);
						send_struct(uart2, &motor_control_struct, motor_controller);
						send_struct(uart3, &motor_control_struct, motor_controller);

//TODO

						signal_telem_struct.id = test_device;
						signal_telem_struct.sig = null_signal;

					break;

					//*************
					// Drive Right
					//*************

					//roveCom::	enum motor_right::	id = 101

					case motor_right:

						motor_control_struct.value = fromBaseMsg.value;

						mux_1( 1 );
						mux_2( 2 );
						mux_3( 3 );

						send_struct(uart1, &motor_control_struct, motor_controller);
						send_struct(uart2, &motor_control_struct, motor_controller);
						send_struct(uart3, &motor_control_struct, motor_controller);

//TODO

						signal_telem_struct.id = test_device;
						signal_telem_struct.sig = null_signal;

					break;

				}//endswitch::		(fromBaseMsg.id)

				//call Telemtery Thread

				//600 as 1/4 the  maxTimeout as reference by ndk::		timeout.tv_sec = 3600 in roveTCPHandler

				Mailbox_post(signalTelemMailbox, &signal_telem_struct, 600);


	}//endwhile:		(1)

	//postcondition: execution will not reach this state unless a serious error occurs

	System_printf("Rove Cmd Cntrl Task Error: Forced Exit\n");
	System_flush();

	//exit Task

	Task_exit();

}//endfnct:		roveCmdCntrl() Task Thread
