/*
 * roveTcpHandler.c
 *
 *  Created on: Jan 22, 2015
 *      Author: Owen Chiaventone, Judah Schad, Connor Walsh
 *
 *  Deals with maintaining a connection to the base station
 *  more detailed documentation is available on the motherboard wiki
 */

#include "roveTcpHandler.h"

Void roveTcpHandler(UArg arg0, UArg arg1)
{

	System_printf("Tcp Handler Task Created\n");
	System_flush();

	fdOpenSession(TaskSelf());

	int                optval = 0;
    int                clientfd = 0;
    int                connect_success = 0;
    int                connectedFlag = NOT_CONNECTED;

    struct timeval     timeout;

    struct sockaddr_in localAddr;
    struct sockaddr_in clientAddr;

    int                bytesSent;
    int                bytesReceived = 0;
    int                JsonBytesRecvd = 0;

    char incomingBuffer[TCPPACKETSIZE];
    char JsonBuffer[JSON_BUFFER_SIZE];

    base_station_msg_struct  fromBaseCmd;

    while(1){

    	System_printf("Attempting to Connect() new connection\n");
    	System_flush();

    	*the_socket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);

		if( (*the_socket) == INVALID_SOCKET ){

			System_printf("failed socket create (%d)\n",fdError());
			System_flush();

    	}//endif

		memset(&localAddr, 0, sizeof(localAddr));

		localAddr.sin_family = AF_INET;
		localAddr.sin_port = htons(TCPPORT);

		System_printf("Assigning Target IP Address\n");

		inet_pton(AF_INET, RED_IP, &localAddr.sin_addr);

		timeout.tv_sec = 3600;
		timeout.tv_usec = 0;

		setsockopt( *the_socket, SOL_SOCKET, SO_SNDTIMEO, &timeout, sizeof( timeout ) );
		setsockopt( *the_socket, SOL_SOCKET, SO_RCVTIMEO, &timeout, sizeof( timeout ) );

		connect_success =  connect( *the_socket, (PSA) &localAddr, sizeof(localAddr) );

    	if(connect_success < 0){

    		connectedFlag = NOT_CONNECTED;
    		System_printf("Error: accept() failed\n");
    		System_flush();

    	} else {

    		connectedFlag = CONNECTED;
    		System_printf("Connected to RED\n");
    		System_flush();

    	}//endif

    	while(connectedFlag == CONNECTED){

    		System_printf("Connected. Waiting for data\n");
    	    System_flush();

    		bytesReceived = recv(clientfd, incomingBuffer, TCPPACKETSIZE, 0);

    		if(bytesReceived < 0){

    			connectedFlag = NOT_CONNECTED;
    			System_printf("Connection lost. (src = recv)\n");
    			System_flush();

    		} else {

    			if(incomingBuffer[0] == '{'){

    				System_printf("\nJson Detected\n");
    				System_flush();

    				JsonBuffer[JsonBytesRecvd] = incomingBuffer[0];
    				JsonBuffer[JsonBytesRecvd+1] = '\0';

    				while( (incomingBuffer[0] != '}') && !(bytesReceived < 0) ){

    		    		bytesReceived = recv(clientfd, incomingBuffer, TCPPACKETSIZE, 0);
    		    		JsonBytesRecvd++;
    		    		JsonBuffer[JsonBytesRecvd] = incomingBuffer[0];
    		    		JsonBuffer[JsonBytesRecvd+1] = '\0';

    				}//endwhile

    				System_printf("Finished Recving Json\n");

    			}//endif

    			//int parseJson(base_station_msg_struct *command, char *JSON_string_buf, int buf_length)
    			//{
    			int index = 0;

    			char Id[5];
    			char Value[10];
    			int cmd_value = = 0;
				char is_end_of_value = 0;
				int value_index = 0;
				int json_value_string_index = 19;

    				// Get Id
    				Id[0] = JSON_string_buf[6];
    				Id[1] = JSON_string_buf[7];
    				Id[2] = JSON_string_buf[8];
    				Id[3] = JSON_string_buf[9];
    				Id[4] = '\0';

    					// Convert cmd value
    				cmd_value = atoi( Id);

    				// Get Value starting at 19
    				Value[0] = '\0';
    				is_end_of_value = 0;
    				value_index = 0;
    				json_value_string_index = 19;

    				while(is_end_of_value == 0)
    				{
    					//Check for ending } which denotes end of value
    					if( JSON_string_buf[json_value_string_index] == '}' )
    					{
    						is_end_of_value = 1;
    						Value[value_index] = '\0';
    					}
    					// this char is a digit of a value
    					else
    					{
    						Value[value_index] = JSON_string_buf[json_value_string_index];
    						value_index++;
    						json_value_string_index++;
    					}
    				}

    				// Convert string value to real value
    				uint8_t value_byte = atoi( Value );

    				// Send data
    				(*command).id = cmd_value;
    				(*command).value = value_byte;
    				return 1;
    			}

e
    			System_printf("Received data: %c\n", incomingBuffer[0]);
    			System_flush();

    			//Put the data in a mailbox
    			Mailbox_post(fromBaseStationMailbox, &fromBaseCmd, BIOS_WAIT_FOREVER);

    		} // endelse

    	} // end while(connectedFlag == CONNECTED)

    	//If execution reaches this point, then the connection has broken
    	close(clientfd);
    } //end while(1)
    //---- postcondition: Execution will not reach this state unless a serious error occurs

    //Close the file descriptor environment opened at the start of the task
    fdCloseSession(TaskSelf());

	System_printf("Tcp Handler Task Exit\n");
	System_flush();
	return;
}

Void roveTcpSender(UArg arg0, UArg arg1)
{

    int  clientfd = (int)arg0;
    int  bytesSent;
    int  KEEPALIVE_SIZE = 9;
    int  isConnected = CONNECTED;

    //MsgObj             toBaseTelem;
    base_station_msg_struct  toBaseTelem;

   char outgoinggBuffer[TCPPACKETSIZE];
   char JsonBuffer[JSON_BUFFER_SIZE];


    System_printf("roveTcpSender: start thread for = 0x%x\n", clientfd);
    while(isConnected == CONNECTED)
    {
    	//Mailbox pend will go here. For now it will just send a keepalive after 2
    	//Mailbox_pend(toBaseStationMailbox, &toBaseTelem, BIOS_WAIT_FOREVER);
    	//generate_json_strings(&outgoinggBuffer, &toBaseTelem.id, &toBaseTelem.value);
    	//bytesSent = send(clientfd, "keepalive", KEEPALIVE_SIZE, 0);
    	//if (bytesSent < 0 || bytesSent != KEEPALIVE_SIZE) {
    	//System_printf("Error: send failed.\n");
    	//isConnected = NOT_CONNECTED;

    	Task_sleep(2000);
        bytesSent = send(clientfd, "keepalive", KEEPALIVE_SIZE, 0);
        if (bytesSent < 0 || bytesSent != KEEPALIVE_SIZE) {
        System_printf("Error: send failed.\n");
        isConnected = NOT_CONNECTED;
        }
     }//endhilw

    System_printf("roveTcpSender: stop thread for = 0x%x\n", clientfd);
    Task_exit();
}


int attemptToConnect(int *the_socket)
{
	int connect_success;
    struct sockaddr_in localAddr;
    struct sockaddr_in clientAddr;
    int                optval;
    //int                optlen = sizeof(optval);
    //socklen_t          addrlen = sizeof(clientAddr);
    struct timeval     timeout; //Timeout settings for client

	//System_printf("Creating socket instance\n");
	//System_flush();
	*the_socket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
	if( (*the_socket) == INVALID_SOCKET )
	{
		System_printf("failed socket create (%d)\n",fdError());
		System_flush();
	}

	//System_printf("Defining Socket Options\n");
	//System_flush();
	//----Define Socket options
	memset(&localAddr, 0, sizeof(localAddr));
	//Use IPv4
	localAddr.sin_family = AF_INET;
	localAddr.sin_port = htons(TCPPORT);
	System_printf("Assigning Target IP Address\n");
	inet_pton(AF_INET, RED_IP, &localAddr.sin_addr);

	//System_printf("Socket Options Set\n");
	//System_flush();
	// Configure our Tx and Rx timeout to be 5 seconds
	timeout.tv_sec = 3600;
	timeout.tv_usec = 0;
	setsockopt( *the_socket, SOL_SOCKET, SO_SNDTIMEO, &timeout, sizeof( timeout ) );
	setsockopt( *the_socket, SOL_SOCKET, SO_RCVTIMEO, &timeout, sizeof( timeout ) );

	//---- Attempt to make the connection
	connect_success =  connect( *the_socket, (PSA) &localAddr, sizeof(localAddr) );

	return connect_success;
}

int parseJson(base_station_msg_struct *command, char *JSON_string_buf, int buf_length)
{
	int index = 0;

	///////////////
	// JSON Parse
	// Author: Keenan Johnson
	//
	// Handwritten for now
	//
	// TODO: fix this and make it less brittle
	///////////////

	char Id[5];
	char Value[10];

	// Get Id
	Id[0] = JSON_string_buf[6];
	Id[1] = JSON_string_buf[7];
	Id[2] = JSON_string_buf[8];
	Id[3] = JSON_string_buf[9];
	Id[4] = '\0';

		// Convert cmd value
	int cmd_value = atoi( Id);

	// Get Value starting at 19
	Value[0] = '\0';
	char is_end_of_value = 0;
	int value_index = 0;
	int json_value_string_index = 19;

	while(is_end_of_value == 0)
	{
		//Check for ending } which denotes end of value
		if( JSON_string_buf[json_value_string_index] == '}' )
		{
			is_end_of_value = 1;
			Value[value_index] = '\0';
		}
		// this char is a digit of a value
		else
		{
			Value[value_index] = JSON_string_buf[json_value_string_index];
			value_index++;
			json_value_string_index++;
		}
	}

	// Convert string value to real value
	uint8_t value_byte = atoi( Value );

	// Send data
	(*command).id = cmd_value;
	(*command).value = value_byte;
	return 1;
}
